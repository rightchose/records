##### 右值

C++11中右值是由两个概念构成的，一个是将亡值，一个是纯右值。其中纯右值就是C++98标准中右值的概念，用于辨别临时变量和一些不跟对象关联的值。将亡值则是C++11新增的跟右值引用相关的表达式，这些表达式，通常是将要被移动的对象（移为他用）。例如返回右值引用的函数的返回值、std::move的返回值、或者转换为右值引用的类型转换函数的返回值。

##### 右值引用

C++11中，右值引用就是对一个右值进行引用的类型。右值一般不具有名字，我们只能通过右值引用去找到它们。我们只能从右值表达式获得右值的引用。如：

```
T && a = ReturnRvalue();
```

这个表达式中，假设ReturnRvalue返回一个右值，我们声明一个名为a的右值引用，其值等于ReturnRvalue函数返回的临时变量的值。

##### 左值引用和右值引用

为了与C++98中的引用类型做区别，把C++98中的引用称为“左值引用”。左值引用和右值引用都是引用类型。不过一个是C++98的一个是C++11的。另外，无论是左值引用还是右值引用，都必须立即进行初始化。左值引用时具名变量值的别名，而右值引用则是不具名（也就是匿名）变量的别名。

上面的例子中，ReturnRvalue函数返回的右值在表达式语句结束后，其生命也就终结了。但是，使用了右值引用的声明，该右值又获得了“新生”，其生命期将与右值引用类型变量a的生命期一样。

不过，右值引用是不能绑定到任何的左值。

```
int c;
int && d = c; // 无法编译通过
```

而在C++98中的左值引用能否绑定到右值呢（使用右值对左值引用进行初始化）？例如

```
T & e = ReturnRvalue();	// 编译错误，左值引用
const T & f = ReturnRvalue(); // 能通过，常量左值引用
```

产生这样的原因是，C++98标准中，常量左值引用可以接受非常量左值，常量右值，右值对其进行初始化。而且在使用右值对其初始化的时候，常量左值引用也可以像右值引用一样将右值的生命期延长。但是相较于右值引用，常量左值引用的右值在它的后续只能是只读的。另外，非常量左值引用只能接受非常量左值对其进行初始化。

##### 如何判断一个类型是否为引用类型，以及是左值引用还是右值引用？

标准库<type_traits>头文件提供了三个模板类`is_rvalue_reference`、`is_lvalue_referenc`、`is_reference`。

